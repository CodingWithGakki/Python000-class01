# week02 学习笔记
## 拦截属性
* __getarrt__ ,__getattribute__.__get__,@property的使用方式及区别

* 同时定义了__getattr__和__getattribute__的话，访问类实例属性只会调用__getattribute__，不管该属性是否存在。只定义了__getattr__没有定义__getattribute__的情况下，访问存在的类实例属性不会调用__getattr__，会返回该属性的值；访问不存在的实例属性的话会调用__getattr__。


## 
* self代表类的实例，而非类，self 不是 python 关键字，我们把他换成其他的词也是可以运行的
* 实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。
* python中使用__init__ 方法作为类的构造函数，并接受参数
* 内置属性
1. __dict__ : 类的属性（包含一个字典，由类的数据属性组成）
2. __doc__ :类的文档字符串
3. __name__: 类名
4. __module__: 类定义所在的模块（类的全名是'__main__.className'，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）
5. __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）

### @classmethod，@staticmethod
classmethod修饰主要目的是为了保证OOA编程的美观性，是一种艺术。 从它们的使用上来看： @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。 @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。 如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。 而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。
## 类的继承
面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。
* 继承语法

```
class 派生类名(基类名)
...
```


在python中继承中的一些特点：
1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：python 子类继承父类构造函数说明。
2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数
3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。
如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" 。
语法：
派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：

```
class SubClassName (ParentClass1[, ParentClass2, ...]):
...
```
实例：

```
class A:        # 定义类 A
.....

class B:         # 定义类 B
.....

class C(A, B):   # 继承类 A 和 B
.....

```

## 方法重写
如果父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法。
## 基础重载方法
序号	方法, 描述 & 简单的调用
1. __init__ ( self [,args...] )
构造函数
简单的调用方法: obj = className(args)
2. __del__( self )
析构方法, 删除一个对象
简单的调用方法 : del obj
3.	__repr__( self )
转化为供解释器读取的形式
简单的调用方法 : repr(obj)
4.	__str__( self )
用于将值转化为适于人阅读的形式
简单的调用方法 : str(obj)
5.	__cmp__ ( self, x )
对象比较
简单的调用方法 : cmp(obj, x)
## 类的属性与方法
### 类的私有属性

__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
### 类的方法

在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数
### 类的私有方法

__private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.__private_methods

## 单下划线、双下划线、头尾双下划线说明：
* __foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。
* _foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *
* __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。